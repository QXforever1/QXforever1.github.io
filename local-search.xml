<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Apk文件结构</title>
    <link href="/2023/04/02/Apk%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <url>/2023/04/02/Apk%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="APK-文件结构"><a href="#APK-文件结构" class="headerlink" title="APK 文件结构"></a>APK 文件结构</h2><p>apk全程Android Package，相当于一个压缩文件，只要在电脑上将apk后缀改为rar或者zip即可解压</p><h3 id="assets目录-（不一定有，但比较常见）"><a href="#assets目录-（不一定有，但比较常见）" class="headerlink" title="assets目录 （不一定有，但比较常见）"></a>assets目录 （不一定有，但比较常见）</h3><p>存放APK的静态资源文件，比如视频、音频、图片等</p><p>静态资源文件主要指存放在assets 文件夹中的文件。assets 文件夹是一种未经编译的资源目录，它会被打包进 APK 文件中，在安装应用程序之后可以被访问。assets 文件夹中的文件不会被解压缩，这意味着它们的访问速度会比较快，但是会占用更多的安装包空间。通常情况下，开发者会将应用程序中的静态文件、配置文件、原始数据或者其他不常改变的文件放在 assets 文件夹中。这样可以使得应用程序的下载包大小变小，并且可以更快速地访问这些文件。</p><h3 id="lib目录（不一定有，但比较常见）"><a href="#lib目录（不一定有，但比较常见）" class="headerlink" title="lib目录（不一定有，但比较常见）"></a>lib目录（不一定有，但比较常见）</h3><p>armeabi-v7a基本通用所有的安卓设备，arm64-v8a只适用于64位的安卓设备，x86常见于安卓模拟器，其目录下的.so文件时c或者c++编译的动态链接库文件</p><p>库文件主要指lib文件夹中的文件，在这个文件夹中，存放了运行APP所需要的so文件，也就是动态链接库的二进制文件。为了适配不同安卓系统处理器的版本，lib文件夹中的so库也是按不同处理器版本的文件夹分类放置。在图3的示例中，分成了三种文件夹包括armeabi、armeabi-v7a和x86文件夹，分别用来存储适配arm5架构、arm7架构、Intel32架构的CPU处理器版本的安卓系统。例如，如果智能手机使用的是arm7架构CPU处理器版本的安卓系统，APP在运行时就会调用armeabi-v7a文件夹下的动态链接库文件执行程序。</p><p>在安卓系统中库文件分文两种，一种是共享库文件（Shared Libraries），另一种是本地库文件（Native Libraries）。共享库文件是可供多个应用程序使用的库，它们被存放在系统目录中。在 Android 系统中，共享库文件以 .so 为后缀，常见的共享库文件包括 libc.so 和 libm.so。</p><p>而lib文件夹存放的就是本地库文件。本地库是专门为应用程序所使用的库，它们被打包进 APK 文件中，在安装应用程序之后会被放到私有目录中。在 Android 系统中，本地库文件也以 .so 为后缀，armeabi-v7a的so文件示例见图4。对于一个 Android 应用程序来说，本地库文件往往是应用程序所特有的，并且不会被其他应用程序使用。例如，一个应用程序可能使用本地库文件来封装特定的硬件访问功能，或者使用本地库文件来进行加密解密操作。</p><h3 id="META-INF目录"><a href="#META-INF目录" class="headerlink" title="META-INF目录"></a>META-INF目录</h3><p>保存应用的签名信息，签名信息可以验证APK文件的完整性，相当于APK的身份证（验证文件是否又被修改）</p><p>签名文件指的是存放在META-INF文件夹中的文件。META-INF 文件夹是 Android 系统中的一种特殊文件夹，它用来存放应用程序的签名信息。在 META-INF 文件夹中可以找到三种常见的文件：CERT.RSA、CERT.SF和MANIFEST.MF，META-INF文件夹示例见图5。CERT.RSA、CERT.SF这两个文件用来存放应用程序的签名信息。当安装一个应用程序时，Android 系统会检查这两个文件，确保应用程序的完整性和安全性。MANIFEST.MF文件用来存放应用程序的所有文件的清单信息。</p><p>当打包应用程序时，这些文件会自动生成，并且会被打包进 APK 文件中。通常情况下，不需要手动修改这些文件，但是有时候可能需要编辑这些文件来更新应用程序的版本号或者修改权限要求。</p><p>META-INF文件夹，用于存放签名证书，在APK安装时作为校验的凭据，用于保护APK不被恶意篡改，同时也是对APK著作权和所有权的声名。例如，对安装包的任意文件最作修改，导致安卓系统检查计算后的签名信息与APK文件中存储的签名信息不一致，最终无法安装，会出现签名冲突的问题。</p><h3 id="res目录"><a href="#res目录" class="headerlink" title="res目录"></a>res目录</h3><p>res目录存放资源文件，包括图片，字符串等等，APK的脸蛋由他的layout文件设计</p><h3 id="res目录与asstes目录的区别"><a href="#res目录与asstes目录的区别" class="headerlink" title="res目录与asstes目录的区别"></a>res目录与asstes目录的区别</h3><ol><li>assets目录不会在R.java文件下生成相应标记，存放到R.java中的资源在运行打包时都会打入程序安装包中</li><li>res目录会在R.java文件下生成相应的标记。</li></ol><p>在res文件夹下还可以定义一下目录：</p><p>res&#x2F;anim:这里存放的是动画资源</p><p>res&#x2F;xml:可以在Activity中使用getResource().getXML()读取这里的资源文件</p><p>res&#x2F;raw:该目录下的文件可以直接复制到设备上，编译软件时，这里的数据不需要编译，直接加入到程序安装包中，使用的方法是getResource().OpenRawResources(ID),其中参数ID的形式是R.raw.XXX、</p><h3 id="res-x2F-raw和assets的相同点"><a href="#res-x2F-raw和assets的相同点" class="headerlink" title="res&#x2F;raw和assets的相同点"></a>res&#x2F;raw和assets的相同点</h3><p>两者目录下的文件在打包后会原封不动的保存在apk包中，不会被编译成二进制</p><h3 id="res-x2F-raw和assets的不同点"><a href="#res-x2F-raw和assets的不同点" class="headerlink" title="res&#x2F;raw和assets的不同点"></a>res&#x2F;raw和assets的不同点</h3><p>1.res&#x2F;raw中的文件会被映射到R.java文件中，访问的时候直接使用资源ID即R.id.filename;assets文件下的文件不会被映射到R.java中，访问的时候需要AssetManger类。</p><p>2.res&#x2F;raw不可以有目录结构，而assets则可以有目录结构，也就是assets目录下可以再建立文件夹</p><h4 id="读取文件资源："><a href="#读取文件资源：" class="headerlink" title="读取文件资源："></a>读取文件资源：</h4><p> 1.读取res&#x2F;raw下的文件资源，通过以下方式获取输入流来进行写操作<br> · InputStream is &#x3D;getResources().openRawResource(R.id.filename);<br> 2.读取assets下的文件资源，通过以下方式获取输入流来进行写操作<br> · AssetManager am &#x3D; null;<br> · am &#x3D; getAssets();<br> · InputStream is &#x3D; am.open(“filename”);</p><h3 id="AndroidMainfest-xml-文件"><a href="#AndroidMainfest-xml-文件" class="headerlink" title="AndroidMainfest.xml 文件"></a>AndroidMainfest.xml 文件</h3><p>APK的应用清单信息，它描述了应用的名字，版本，权限，引用的库文件等等信息</p><p>xml文件中存放着应用的Activity信息</p><h3 id="classes-dex文件"><a href="#classes-dex文件" class="headerlink" title="classes.dex文件"></a>classes.dex文件</h3><p>classes.dex是java源码编译后生成的java字节码文件，APK运行的主要逻辑，是apk文件的核心代码文件</p><p>核心代码文件主要指classes.dex文件。classes.dex文件是 Android 系统中的重要代码文件，它是 Dalvik 可执行文件的缩写。Dalvik 是 Android 系统中的一种虚拟机，它负责在 Android 系统中运行应用程序的代码。classes.dex文件运行在Dalvik虚拟机上的核心代码文件，它反编译后的语言是smali代码语言，smali代码可转换为java代码。对于大的APK文件会出现多个dex文件，但在APP实际运行的过程中会将多个dex文件合并成一个dex文件运行。APK打包时存放多个dex的原因是每个dex文件的大小是有限制的。</p><p>.dex 文件中存放的是 Java 字节码，这是 Java 编译器编译出来的机器码。.dex 文件本身是一种二进制文件，它使用一种特殊的格式来存放字节码。</p><p>在打包 Android 应用程序时，.dex 文件会自动生成，并且会被打包进 APK 文件中。当你安装应用程序时，.dex 文件会被解压缩并放到私有目录中，然后被 Dalvik 虚拟机加载并运行。</p><p>.dex 文件的好处是，它可以使得应用程序的下载包大小变小，因为 Java 字节码文件可以被压缩得比较小。但是，.dex 文件的缺点是，它的访问速度略慢于共享库文件。因此，在 Android 系统中，一般情况下会尽量使用共享库文件来实现应用程序的功能。</p><h3 id="resources-arsc文件"><a href="#resources-arsc文件" class="headerlink" title="resources.arsc文件"></a>resources.arsc文件</h3><p>resources.arsc是编译后的二进制资源文件，它是一个映射表，映射着资源和id，通过R文件中的id就可以找到对应的资源</p><p>AndroidManifest.xml文件是整个应用程序的信息描述文件，定义了应用程序中包含的Activity,Service,Content provider和BroadcastReceiver组件信息。每个应用程序在根目录下必须包含一个AndroidManifest.xml文件，且文件名不能修改。它描述了package中暴露的组件，他们各自的实现类，各种能被处理的数据和启动位置。</p><table><thead><tr><th>versionCode</th><th>版本号，主要用来更新，例如:12</th></tr></thead><tbody><tr><td>versionName</td><td>版本名，给用户看的，例如:1.2</td></tr><tr><td>package</td><td>包名，例如：com.zj.52pj.demo</td></tr><tr><td>uses-permission android:name&#x3D;””</td><td>应用权限，例如：android.permission.INTERNET 代表网络权限</td></tr><tr><td>android:label&#x3D;”@string&#x2F;app_name”</td><td>应用名称</td></tr><tr><td>android:icon&#x3D;”@mipmap&#x2F;ic_launcher”</td><td>应用图标路径</td></tr><tr><td>android:debuggable&#x3D;”true”</td><td>应用是否开启debug权</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
